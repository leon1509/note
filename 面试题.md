## 1. 设计模式-六大原则
### 1.1 单一职责原则
    一个类只负责一项职责
### 1.2 里氏替换原则
    子类可以扩展父类的功能，但是不要改变父类原有的功能
### 1.3 依赖倒置原则
    面向接口编程
### 1.4 接口隔离原则
    接口设计细粒度化，实现最小功能单元
### 1.5 迪米特法则
    降低耦合（在局部变量或方法块中，不要使用新的类）
### 1.6 开闭原则
    对扩展开放，对修改关闭

## 2. OSI七层传输
```
1. 物理层
2. 数据链路层
3. 网络层
4. 传输层   tcp udp
5. 会话层
6. 表示层
7. 应用层  http https ftp smtp
```
## 3. TCP/IP四层传输
```
1. 链路层
2. 网络层 ip
3. 传输层 tcp
4. 应用层 http https
```
## 4. a系统给b系统转账100元
```
1. 如何保证数据一致性（使用乐观锁保证，即所谓的“幂等性”）
2. 如何保证性能 （使用spring编程式事务）
3. 使用CAS乐观锁
```
## 5. 类加载机制
```
七个阶段：加载->验证->准备->解析->初始化->使用->卸载
```
## 6. 框架如何选型
```
1. 生态
2. 成功案例
3. 效率（运行效率、学习效率）
```
## 7. 单体架构迁移到微服务原则
```
1. 影响可控
2. 可回退 — 做好回滚/降级预案
3. 可追溯 — 出现总是，有日志或备份数据可查
4. 可测试 —  迁移方案必须可测试
```
## 8. 大数据发展史-组件
```
Google      Hadoop
            Lucene 基于文本搜索的函数库
            Nutch 开源搜索引擎
GFS         NDFS ->HDFS 分布式文件存储系统
MapReduce   MapReduce（编程模型）
BigTable    Hbase   分布式数据存储系统
```
## 9. 数据库迁移方案
```
mysql为例 可使用阿里的canal将binlog日志采集并发送到MQ队列，然后消息消费者「通过ACK机制 确认处理」 这条更新消息，删除缓存，保证数据缓存一致性。
```
## 10. 栈溢出的几种情况及解决方案
```
1. 局部数组过大
   当函数内部的数组过大时，有可能导致堆栈溢出。
2. 递归调用层次太多
   递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。
3. 指针或数组越界
   这种情况最常见，例如进行字符串拷贝或处理用户输入等。

解决方案：一是增大栈空间，二是改用动态分配，使用堆（heap）而不是栈（stack）
```
## 11. 如何保证MQ消息不丢失
```
MQ丢失消息分三种情况（以RabbitMQ为例）：
  1. 生产者丢失消息
     1.1 开启RabbitMQ事务 -- 同步阻塞
     1.2 生产者开启Confirm模式（每次写消息会分配一个唯一ID，成功后会接收MQ的一个ack消息，否则MQ会回调生产者nack接口，这时可以重新发送。） -- 异步机制
  2. MQ丢失消息
     设置消息持久化到磁盘，有2个步骤！由生产者设置，1）创建queue时将其设置为持久化的。2）发送消息时设置deliveryMode=2。跟上面的Confirm配合使用。
  3. 消费者丢失消息
     使用MQ提供的ack机制。
```
